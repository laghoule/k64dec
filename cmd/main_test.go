package main

import (
	"bytes"
	"fmt"
	"os"
	"testing"

	"github.com/pterm/pterm"
	"github.com/stretchr/testify/assert"
)

const (
	testDataDir          = "../testdata"
	testDataExpectedDir  = testDataDir + "/expected"
	secretDataTLSYaml    = "secretDataTLSYaml"
	secretStringDataYaml = "secretStringDataYaml"
	secretDataYaml       = "secretDataYaml"
	secretDataJson       = "secretDataJson"
	badSecret            = "badSecret"
)

func captureConsoleOutput(f func()) []byte {
	var buf bytes.Buffer
	pterm.SetDefaultOutput(&buf)

	f()

	pterm.SetDefaultOutput(os.Stderr)
	return buf.Bytes()
}

func TestPrintVersion(t *testing.T) {
	captured := captureConsoleOutput(
		func() {
			if err := printVersion(); err != nil {
				t.Error(err)
				return
			}
		},
	)

	expected := []byte{0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x39, 0x36, 0x6d, 0x1b, 0x5b, 0x39, 0x36, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x20, 0x7c, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x39, 0x36, 0x6d, 0x1b, 0x5b, 0x39, 0x36, 0x6d, 0x47, 0x69, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x20, 0x7c, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x39, 0x36, 0x6d, 0x1b, 0x5b, 0x39, 0x36, 0x6d, 0x47, 0x69, 0x74, 0x20, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0xa, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x64, 0x65, 0x76, 0x65, 0x6c, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x20, 0x7c, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x1b, 0x5b, 0x39, 0x30, 0x6d, 0x20, 0x7c, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x1b, 0x5b, 0x33, 0x39, 0x6d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0xa}
	assert.Equal(t, expected, captured)
}

func TestReadFromSTDIN(t *testing.T) {
	var testCase = []string{
		secretDataYaml,
		secretDataJson,
		secretDataTLSYaml,
	}

	for _, test := range testCase {
		secretFile := fmt.Sprintf("%s/%s", testDataDir, test)

		input, err := os.Open(secretFile)
		if err != nil {
			t.Error(err)
			return
		}

		defer input.Close()
		os.Stdin = input

		_, err = input.Read([]byte{})
		if err != nil {
			t.Error(err)
			return
		}

		data, err := readFromSTDIN()
		if err != nil {
			t.Error(err)
			return
		}

		expected, err := os.ReadFile(secretFile)
		if err != nil {
			t.Error(err)
			return
		}

		assert.Equal(t, expected, data)
	}

}

func createTempFile(size int) (string, error) {
	f, err := os.CreateTemp(os.TempDir(), "k64dec-")
	if err != nil {
		return "", fmt.Errorf("failed to create temporary file %s/%s", os.TempDir(), f.Name())
	}

	defer f.Close()

	var data []byte
	for i := 0; i <= size; i++ {
		data = append(data, 0)
	}

	_, err = f.Write(data)
	if err != nil {
		return "", err
	}

	return f.Name(), nil
}

func TestReadFromSTDINMaxsize(t *testing.T) {
	fileName, err := createTempFile(maxSize)
	if err != nil {
		t.Error(err)
		return
	}

	defer func() {
		if err := os.Remove(fileName); err != nil {
			t.Error(err)
			return
		}
	}()

	f, err := os.Open(fileName)
	if err != nil {
		t.Error(t)
		return
	}

	os.Stdin = f

	_, err = f.Read([]byte{})
	if err != nil {
		t.Error(err)
		return
	}

	_, err = readFromSTDIN()
	assert.ErrorContains(t, err, "max read buffer reach")
}
